---
title: 'Schnellstart: C#Â SDK fÃ¼r FormularerkennungÂ v3.0 | Vorschau'
titleSuffix: Azure Applied AI Services
description: Formular- und Dokumentverarbeitung, Datenextraktion und Analyse mit C#-Clientbibliothek-SDKs fÃ¼r FormularerkennungÂ v3.0 (Vorschau)
author: laujan
manager: nitinme
ms.service: applied-ai-services
ms.subservice: forms-recognizer
ms.topic: quickstart
ms.date: 10/07/2021
ms.author: lajanuar
recommendations: false
ms.openlocfilehash: 50c1cfbcfc79212f03fd67f783afaff110ce1e09
ms.sourcegitcommit: 692382974e1ac868a2672b67af2d33e593c91d60
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 10/22/2021
ms.locfileid: "130216730"
---
# <a name="quickstart-form-recognizer-c-client-library-sdks-v30--preview"></a>Schnellstart: C#-Clientbibliothek-SDKs fÃ¼r FormularerkennungÂ v3.0 | Vorschau

Informieren Sie sich Ã¼ber die ersten Schritte mit der Azure-Formularerkennung mit der ProgrammierspracheÂ C#. Azure-Formularerkennung ist ein Clouddienst unter [Azure Applied AI Services](../../../applied-ai-services/index.yml), mit dem Sie Ã¼ber die Technologie fÃ¼r maschinelles Lernen Software fÃ¼r die automatisierte Datenverarbeitung entwickeln kÃ¶nnen. Sie kÃ¶nnen die Formularerkennung per REST-API oder SDK verwenden. Sie sollten den kostenlosen Dienst nutzen, wenn Sie die Technologie erlernen. Bedenken Sie, dass die Anzahl der kostenlosen Seiten auf 500 pro Monat beschrÃ¤nkt ist.

>[!NOTE]
> FormularerkennungÂ v3.0 befindet sich derzeit in der Ã¶ffentlichen Vorschauphase. Dies bedeutet, dass einige Features unter UmstÃ¤nden nicht unterstÃ¼tzt werden oder nur eingeschrÃ¤nkt verwendbar sind. 

[Referenzdokumentation](/dotnet/api/overview/azure/ai.formrecognizer-readme?view=azure-dotnet&preserve-view=true ) | [Quellcode der Bibliothek](https://github.com/Azure/azure-sdk-for-net/tree/master/sdk/formrecognizer/Azure.AI.FormRecognizer/src) | [Paket (NuGet)](https://www.nuget.org/packages/Azure.AI.FormRecognizer) | [Beispiele](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/formrecognizer/Azure.AI.FormRecognizer/samples/README.md)

Die Formularerkennung unter Azure Cognitive Services ist ein Clouddienst, bei dem maschinelles Lernen genutzt wird, um Formularfelder, Text und Tabellen aus Ihren Dokumenten zu extrahieren und zu analysieren. Sie kÃ¶nnen Formularerkennungsmodelle leicht aufrufen, indem Sie unsere Clientbibliothek-SDKs in Ihre Workflows und Anwendungen integrieren.

### <a name="form-recognizer-models"></a>Formularerkennungsmodelle

Das C#Â SDK unterstÃ¼tzt die folgenden Modelle und Funktionen:

* ðŸ†•Allgemeines Dokument: Analysieren und Extrahieren von Text, Tabellen, Struktur, SchlÃ¼ssel-Wert-Paaren und benannten EntitÃ¤ten.|
* Layout: Analysieren und Extrahieren von Tabellen, Zeilen, WÃ¶rtern und Auswahlmarkierungen, z.Â B. Optionsfelder und KontrollkÃ¤stchen in Formulardokumenten, ohne ein Modell trainieren zu mÃ¼ssen.
* Benutzerdefiniert: Analysieren und Extrahieren von Formularfeldern und anderen Inhalten aus Ihren benutzerdefinierten Formularen mit Modellen, die Sie mit Ihren eigenen Formulartypen trainiert haben.
* Rechnungen: Analysieren und Extrahieren hÃ¤ufig verwendeter Felder aus Rechnungen Ã¼ber ein vortrainiertes Rechnungsmodell.
* Belege: Analysieren und Extrahieren hÃ¤ufig verwendeter Felder aus Belegen Ã¼ber ein vortrainiertes Belegmodell.
* Ausweisdokumente: Analysieren und Extrahieren hÃ¤ufig verwendeter Felder aus Ausweisdokumenten, z.Â B. PÃ¤ssen oder FÃ¼hrerscheinen, mit einem vortrainierten Modell fÃ¼r Ausweisdokumente.
* Visitenkarten: Analysieren und Extrahieren hÃ¤ufig verwendeter Felder aus Visitenkarten mit einem vortrainierten Modell fÃ¼r Visitenkarten.

In dieser Schnellstartanleitung verwenden Sie die folgenden Funktionen, um Daten und Werte aus Formularen und Dokumenten zu analysieren und zu extrahieren:

* [**Allgemeines Dokument**](#try-it-general-document-model)

* [**Layout**](#try-it-layout-model)

* [**Vordefinierte Rechnung**](#try-it-prebuilt-invoice-model)

## <a name="prerequisites"></a>Voraussetzungen

* Azure-Abonnement â€“ [Erstellen eines kostenlosen Kontos](https://azure.microsoft.com/free/cognitive-services/)

* Aktuelle Version der [Visual Studio-IDE](https://visualstudio.microsoft.com/vs/) oder [.NET Core](https://dotnet.microsoft.com/download).

* Eine Cognitive Services- oder Formularerkennungsressource. Wenn Sie Ã¼ber Ihr Azure-Abonnement verfÃ¼gen, kÃ¶nnen Sie im Azure-Portal eine Formularerkennungsressource mit [einem Dienst](https://ms.portal.azure.com/#create/Microsoft.CognitiveServicesFormRecognizer) oder [mehreren Diensten](https://ms.portal.azure.com/#create/Microsoft.CognitiveServicesAllInOne) erstellen, um Ihren SchlÃ¼ssel und Endpunkt zu erhalten. Sie kÃ¶nnen den kostenlosen Tarif (`F0`) verwenden, um den Dienst zu testen, und spÃ¤ter fÃ¼r die Produktion auf einen kostenpflichtigen Tarif upgraden.

> [!TIP] 
> Erstellen Sie eine Cognitive Services-Ressource, wenn Sie planen, Ã¼ber einen einzelnen Endpunkt bzw. SchlÃ¼ssel auf mehrere Cognitive Services-Instanzen zuzugreifen. Erstellen Sie eine Formularerkennungsressource, falls nur auf die Formularerkennung zugegriffen werden soll. Beachten Sie hierbei, dass Sie eine Ressource mit einem einzelnen Dienst benÃ¶tigen, falls Sie die [Azure Active Directory-Authentifizierung](../../../active-directory/authentication/overview-authentication.md) nutzen mÃ¶chten.

* Klicken Sie nach der Bereitstellung Ihrer Ressource auf **Zu Ressource wechseln**. Sie benÃ¶tigen den SchlÃ¼ssel und Endpunkt der von Ihnen erstellten Ressource, um Ihre Anwendung mit der Formularerkennungs-API zu verbinden. Der SchlÃ¼ssel und der Endpunkt werden weiter unten in der Schnellstartanleitung in den Code eingefÃ¼gt:

  :::image type="content" source="../media/containers/keys-and-endpoint.png" alt-text="Screenshot: SchlÃ¼ssel und Endpunkt im Azure-Portal":::

## <a name="set-up"></a>Einrichten

### <a name="option-1-net-command-line-interface-cli"></a>[OptionÂ 1: .NET-Befehlszeilenschnittstelle (Command-Line Interface, CLI)](#tab/cli)

Verwenden Sie in einem Konsolenfenster (z.Â B. cmd, PowerShell oder Bash) den Befehl `dotnet new` zum Erstellen einer neuen Konsolen-App mit dem Namen `formrecognizer-quickstart`. Dieser Befehl erstellt ein einfaches â€žHallo Weltâ€œ-C#-Projekt mit einer einzigen Quelldatei: *Program.cs*.

```console
dotnet new console -n formrecognizer-quickstart
```

Ã–ffnen Sie eine Befehlszeile, und wechseln Sie zu dem Verzeichnis, das Ihre Projektdatei enthÃ¤lt. Erstellen Sie die Anwendung mit:

```console
dotnet build
```

Die Buildausgabe sollte keine Warnungen oder Fehler enthalten.

```console
...
Build succeeded.
 0 Warning(s)
 0 Error(s)
...
```

### <a name="install-the-client-library-with-nuget"></a>Installieren der Clientbibliothek mit NuGet

Installieren Sie in dem Verzeichnis, das Ihr Projekt enthÃ¤lt, mit dem folgenden Befehl die Clientbibliothek der Formularerkennung fÃ¼r .NET:

```console
dotnet add package Azure.AI.FormRecognizer
```

FÃ¼r diese Version der Clientbibliothek wird standardmÃ¤ÃŸig die Version â€ž2021-09-30-previewâ€œ des Diensts verwendet.

### <a name="option-2-visual-studio"></a>[Option 2: Visual Studio](#tab/vs)

1. Starten Sie Visual Studio 2019.

1. WÃ¤hlen Sie auf der Startseite Neues Projekt erstellen aus.

    :::image type="content" source="../media/quickstarts/start-window.png" alt-text="Screenshot: Visual Studio-Startfenster":::

1. Geben Sie auf der Seite **Neues Projekt erstellen** im Suchfeld den Suchbegriff **Konsole** ein. WÃ¤hlen Sie die Vorlage **Konsolenanwendung** und dann **Weiter** aus.

    :::image type="content" source="../media/quickstarts/create-new-project.png" alt-text="Screenshot: Seite â€žNeues Projekt erstellenâ€œ in Visual Studio":::

1. Geben Sie im Dialogfeld **Neues Projekt konfigurieren** im Feld fÃ¼r den Projektnamen den Namen `formRecognizer_quickstart` ein. WÃ¤hlen Sie anschlieÃŸend â€žWeiterâ€œ aus.

    :::image type="content" source="../media/quickstarts/configure-new-project.png" alt-text="Screenshot: Dialogfeld â€žNeues Projekt konfigurierenâ€œ in Visual Studio":::

1. WÃ¤hlen Sie im Dialogfeld **Weitere Informationen** die Option **.NETÂ 5.0 (aktuell)** und dann **Erstellen** aus.

    :::image type="content" source="../media/quickstarts/additional-information.png" alt-text="Screenshot: Dialogfeld â€žWeitere Informationenâ€œ in Visual Studio":::

### <a name="install-the-client-library-with-nuget"></a>Installieren der Clientbibliothek mit NuGet

 1. Klicken Sie mit der rechten Maustaste auf das Projekt **formRecognizer_quickstart**, und wÃ¤hlen Sie die Option **NuGet-Pakete verwalten...** aus.

    :::image type="content" source="../media/quickstarts/select-nuget-package.png" alt-text="Screenshot: select-nuget-package.png":::

 1. WÃ¤hlen Sie die Registerkarte â€žDurchsuchenâ€œ aus, und geben Sie â€žAzure.AI.FormRecognizerâ€œ ein.

     :::image type="content" source="../media/quickstarts/azure-nuget-package.png" alt-text="Screenshot: select-form-recognizer-package.png":::

 1. WÃ¤hlen Sie im DropdownmenÃ¼ die gewÃ¼nschte Version und anschlieÃŸend die Option **Installieren** aus.

     FÃ¼r diese Version der Clientbibliothek wird standardmÃ¤ÃŸig die Version â€ž2021-09-30-previewâ€œ des Diensts verwendet.

---

## <a name="build-your-application"></a>Erstellen Ihrer Anwendung

FÃ¼r die Interaktion mit dem Dienst â€žFormularerkennungâ€œ mÃ¼ssen Sie eine Instanz der `DocumentAnalysisClient`-Klasse erstellen. Erstellen Sie hierfÃ¼r ein `AzureKeyCredential`-Element mit Ihrem â€žapiKeyâ€œ und eine `DocumentAnalysisClient`-Instanz mit dem `AzureKeyCredential`-Element und Ihrem `endpoint` fÃ¼r die Formularerkennung.

1. Ã–ffnen Sie die Datei **Program.cs**.

1. FÃ¼gen Sie die folgenden using-Direktiven ein:

    ```csharp
    using System;
    using System.Threading.Tasks;
    using Azure.AI.FormRecognizer.DocumentAnalysis;
    ```

1. Legen Sie Ihre Umgebungsvariablen `endpoint` und `apiKey` fest, und erstellen Sie Ihre `AzureKeyCredential`- und `DocumentAnalysisClient`-Instanz:

    ```csharp
    string endpoint = "<your-endpoint>";
    string apiKey = "<your-apiKey>";
    var credential = new AzureKeyCredential(apiKey);
    var client = new DocumentAnalysisClient(new Uri(endpoint), credential);
    ```

1. LÃ¶schen Sie die Zeile `Console.Writeline("Hello World!");`, und fÃ¼gen Sie den Code fÃ¼r **Try It** (Ausprobieren) der **Main**-Methode in der Datei **Program.cs** hinzu:

    :::image type="content" source="../media/quickstarts/add-code-here.png" alt-text="Screenshot: HinzufÃ¼gen des Beispielcodes zur â€žMainâ€œ-Methode":::

## <a name="try-it-general-document-model"></a>**Try it** (Ausprobieren): Allgemeines Dokumentmodell

> [!div class="checklist"]
>
> * FÃ¼r dieses Beispiel benÃ¶tigen Sie eine **Formulardokumentdatei unter einem URI**. Sie kÃ¶nnen fÃ¼r diese Schnellstartanleitung unser [Beispielformulardokument](https://raw.githubusercontent.com/Azure-Samples/cognitive-services-REST-api-samples/master/curl/form-recognizer/sample-layout.pdf) verwenden.
> * FÃ¼gen Sie den Datei-URI-Wert oben in der â€žMainâ€œ-Methode der Variablen `string fileUri` hinzu.
> * FÃ¼r die Analyse einer bestimmten Datei unter einem URI verwenden Sie die `StartAnalyzeDocumentFromUri`-Methode. Der zurÃ¼ckgegebene Wert ist ein `AnalyzeResult`-Objekt mit Daten zum Ã¼bermittelten Dokument.

### <a name="add-the-following-code-to-your-general-document-application-main-method"></a>FÃ¼gen Sie der **Main**-Methode Ihrer allgemeinen Dokumentanwendung den folgenden Code hinzu:

```csharp
// sample form document
string fileUri = "https://raw.githubusercontent.com/Azure-Samples/cognitive-services-REST-api-samples/master/curl/form-recognizer/sample-layout.pdf";

AnalyzeDocumentOperation operation = await client.StartAnalyzeDocumentFromUriAsync("prebuilt-document", fileUri);

await operation.WaitForCompletionAsync();

AnalyzeResult result = operation.Value;

Console.WriteLine("Detected entities:");

foreach (DocumentEntity entity in result.Entities)
{
    if (entity.SubCategory == null)
    {
        Console.WriteLine($"  Found entity '{entity.Content}' with category '{entity.Category}'.");
    }
    else
    {
        Console.WriteLine($"  Found entity '{entity.Content}' with category '{entity.Category}' and sub-category '{entity.SubCategory}'.");
    }
}

Console.WriteLine("Detected key-value pairs:");

foreach (DocumentKeyValuePair kvp in result.KeyValuePairs)
{
    if (kvp.Value.Content == null)
    {
        Console.WriteLine($"  Found key with no value: '{kvp.Key.Content}'");
    }
    else
    {
        Console.WriteLine($"  Found key-value pair: '{kvp.Key.Content}' and '{kvp.Value.Content}'");
    }
}

foreach (DocumentPage page in result.Pages)
{
    Console.WriteLine($"Document Page {page.PageNumber} has {page.Lines.Count} line(s), {page.Words.Count} word(s),");
    Console.WriteLine($"and {page.SelectionMarks.Count} selection mark(s).");

    for (int i = 0; i < page.Lines.Count; i++)
    {
        DocumentLine line = page.Lines[i];
        Console.WriteLine($"  Line {i} has content: '{line.Content}'.");

        Console.WriteLine($"    Its bounding box is:");
        Console.WriteLine($"      Upper left => X: {line.BoundingBox[0].X}, Y= {line.BoundingBox[0].Y}");
        Console.WriteLine($"      Upper right => X: {line.BoundingBox[1].X}, Y= {line.BoundingBox[1].Y}");
        Console.WriteLine($"      Lower right => X: {line.BoundingBox[2].X}, Y= {line.BoundingBox[2].Y}");
        Console.WriteLine($"      Lower left => X: {line.BoundingBox[3].X}, Y= {line.BoundingBox[3].Y}");
    }

    for (int i = 0; i < page.SelectionMarks.Count; i++)
    {
        DocumentSelectionMark selectionMark = page.SelectionMarks[i];

        Console.WriteLine($"  Selection Mark {i} is {selectionMark.State}.");
        Console.WriteLine($"    Its bounding box is:");
        Console.WriteLine($"      Upper left => X: {selectionMark.BoundingBox[0].X}, Y= {selectionMark.BoundingBox[0].Y}");
        Console.WriteLine($"      Upper right => X: {selectionMark.BoundingBox[1].X}, Y= {selectionMark.BoundingBox[1].Y}");
        Console.WriteLine($"      Lower right => X: {selectionMark.BoundingBox[2].X}, Y= {selectionMark.BoundingBox[2].Y}");
        Console.WriteLine($"      Lower left => X: {selectionMark.BoundingBox[3].X}, Y= {selectionMark.BoundingBox[3].Y}");
    }
}

foreach (DocumentStyle style in result.Styles)
{
    // Check the style and style confidence to see if text is handwritten.
    // Note that value '0.8' is used as an example.

    bool isHandwritten = style.IsHandwritten.HasValue && style.IsHandwritten == true;

    if (isHandwritten && style.Confidence > 0.8)
    {
        Console.WriteLine($"Handwritten content found:");

        foreach (DocumentSpan span in style.Spans)
        {
            Console.WriteLine($"  Content: {result.Content.Substring(span.Offset, span.Length)}");
        }
    }
}

Console.WriteLine("The following tables were extracted:");

for (int i = 0; i < result.Tables.Count; i++)
{
    DocumentTable table = result.Tables[i];
    Console.WriteLine($"  Table {i} has {table.RowCount} rows and {table.ColumnCount} columns.");

    foreach (DocumentTableCell cell in table.Cells)
    {
        Console.WriteLine($"    Cell ({cell.RowIndex}, {cell.ColumnIndex}) has kind '{cell.Kind}' and content: '{cell.Content}'.");
    }
}

```

## <a name="try-it-layout-model"></a>**Try it** (Ausprobieren): Layoutmodell

Dient zum Extrahieren von Text, Auswahlmarkierungen, Textformaten und Tabellenstrukturen sowie der zugehÃ¶rigen Begrenzungsbereichskoordinaten aus Dokumenten.

> [!div class="checklist"]
>
> * FÃ¼r dieses Beispiel benÃ¶tigen Sie eine **Formulardokumentdatei unter einem URI**. Sie kÃ¶nnen fÃ¼r diese Schnellstartanleitung unser [Beispielformulardokument](https://raw.githubusercontent.com/Azure-Samples/cognitive-services-REST-api-samples/master/curl/form-recognizer/sample-layout.pdf) verwenden.
> * FÃ¼gen Sie den Datei-URI-Wert oben in der â€žMainâ€œ-Methode der Variablen `string fileUri` hinzu.
> * Verwenden Sie zum Extrahieren des Layouts aus einer bestimmten Datei unter einem URI die `StartAnalyzeDocumentFromUri`-Methode, und Ã¼bergeben Sie `prebuilt-layout` als Modell-ID. Der zurÃ¼ckgegebene Wert ist ein `AnalyzeResult`-Objekt mit Daten aus dem Ã¼bermittelten Dokument.

### <a name="add-the-following-code-to-your-layout-application-main-method"></a>FÃ¼gen Sie der **Main**-Methode Ihrer Layoutanwendung den folgenden Code hinzu:

```csharp
// sample form document
string fileUri = "https://raw.githubusercontent.com/Azure-Samples/cognitive-services-REST-api-samples/master/curl/form-recognizer/sample-layout.pdf";

AnalyzeDocumentOperation operation = await client.StartAnalyzeDocumentFromUriAsync("prebuilt-layout", fileUri);

await operation.WaitForCompletionAsync();

AnalyzeResult result = operation.Value;

foreach (DocumentPage page in result.Pages)
{
    Console.WriteLine($"Document Page {page.PageNumber} has {page.Lines.Count} line(s), {page.Words.Count} word(s),");
    Console.WriteLine($"and {page.SelectionMarks.Count} selection mark(s).");

    for (int i = 0; i < page.Lines.Count; i++)
    {
        DocumentLine line = page.Lines[i];
        Console.WriteLine($"  Line {i} has content: '{line.Content}'.");

        Console.WriteLine($"    Its bounding box is:");
        Console.WriteLine($"      Upper left => X: {line.BoundingBox[0].X}, Y= {line.BoundingBox[0].Y}");
        Console.WriteLine($"      Upper right => X: {line.BoundingBox[1].X}, Y= {line.BoundingBox[1].Y}");
        Console.WriteLine($"      Lower right => X: {line.BoundingBox[2].X}, Y= {line.BoundingBox[2].Y}");
        Console.WriteLine($"      Lower left => X: {line.BoundingBox[3].X}, Y= {line.BoundingBox[3].Y}");
    }

    for (int i = 0; i < page.SelectionMarks.Count; i++)
    {
        DocumentSelectionMark selectionMark = page.SelectionMarks[i];

        Console.WriteLine($"  Selection Mark {i} is {selectionMark.State}.");
        Console.WriteLine($"    Its bounding box is:");
        Console.WriteLine($"      Upper left => X: {selectionMark.BoundingBox[0].X}, Y= {selectionMark.BoundingBox[0].Y}");
        Console.WriteLine($"      Upper right => X: {selectionMark.BoundingBox[1].X}, Y= {selectionMark.BoundingBox[1].Y}");
        Console.WriteLine($"      Lower right => X: {selectionMark.BoundingBox[2].X}, Y= {selectionMark.BoundingBox[2].Y}");
        Console.WriteLine($"      Lower left => X: {selectionMark.BoundingBox[3].X}, Y= {selectionMark.BoundingBox[3].Y}");
    }
}

foreach (DocumentStyle style in result.Styles)
{
    // Check the style and style confidence to see if text is handwritten.
    // Note that value '0.8' is used as an example.

    bool isHandwritten = style.IsHandwritten.HasValue && style.IsHandwritten == true;

    if (isHandwritten && style.Confidence > 0.8)
    {
        Console.WriteLine($"Handwritten content found:");

        foreach (DocumentSpan span in style.Spans)
        {
            Console.WriteLine($"  Content: {result.Content.Substring(span.Offset, span.Length)}");
        }
    }
}

Console.WriteLine("The following tables were extracted:");

for (int i = 0; i < result.Tables.Count; i++)
{
    DocumentTable table = result.Tables[i];
    Console.WriteLine($"  Table {i} has {table.RowCount} rows and {table.ColumnCount} columns.");

    foreach (DocumentTableCell cell in table.Cells)
    {
        Console.WriteLine($"    Cell ({cell.RowIndex}, {cell.ColumnIndex}) has kind '{cell.Kind}' and content: '{cell.Content}'.");
    }
}

```

## <a name="try-it-prebuilt-invoice-model"></a>**Try it** (Ausprobieren): Vordefiniertes Rechnungsmodell

In diesem Beispiel wird veranschaulicht, wie Sie Daten aus bestimmten Arten von hÃ¤ufig verwendeten Dokumenten mit vortrainierten Modellen analysieren, indem eine Rechnung als Beispiel verwendet wird.

> [!div class="checklist"]
>
> * FÃ¼r dieses Beispiel benÃ¶tigen Sie eine **Rechnungsdokumentdatei unter einem URI**. FÃ¼r diese Schnellstartanleitung kÃ¶nnen Sie unser [Beispiel fÃ¼r ein Rechnungsdokument](https://raw.githubusercontent.com/Azure-Samples/cognitive-services-REST-api-samples/master/curl/form-recognizer/sample-invoice.pdf) verwenden.
> * FÃ¼gen Sie den Datei-URI-Wert oben in der â€žMainâ€œ-Methode der Variablen `string fileUri` hinzu.
> * Verwenden Sie zum Analysieren einer bestimmten Datei unter einem URI die `StartAnalyzeDocumentFromUri`-Methode, und Ã¼bergeben Sie `prebuilt-invoice` als Modell-ID. Der zurÃ¼ckgegebene Wert ist ein `AnalyzeResult`-Objekt mit Daten aus dem Ã¼bermittelten Dokument.

### <a name="choose-the-invoice-prebuilt-model-id"></a>AuswÃ¤hlen der ID fÃ¼r das vordefinierte Rechnungsmodell

Sie sind hierbei nicht auf Rechnungen beschrÃ¤nkt, sondern kÃ¶nnen zwischen mehreren vordefinierten Modellen wÃ¤hlen, von denen jedes Ã¼ber eine Gruppe unterstÃ¼tzter Felder verfÃ¼gt. Welches Modell fÃ¼r den Analysevorgang verwendet wird, hÃ¤ngt vom Typ des zu analysierenden Dokuments ab. Hier sind die Modell-IDs fÃ¼r die vordefinierten Modelle angegeben, die vom Dienst â€žFormularerkennungâ€œ derzeit unterstÃ¼tzt werden:

* **prebuilt-invoice**: Dient zum Extrahieren von Text, Auswahlmarkierungen, Tabellen, SchlÃ¼ssel-Wert-Paaren und wichtigen Informationen aus Rechnungen.
* **prebuilt-businessCard**: Dient zum Extrahieren von Text und wichtigen Informationen aus Visitenkarten.
* **prebuilt-idDocument**: Dient zum Extrahieren von Text und wichtigen Informationen aus FÃ¼hrerscheinen und ReisepÃ¤ssen.
* **prebuilt-receipt**: Dient zum Extrahieren von Text und wichtigen Informationen aus Belegen.

### <a name="add-the-following-code-to-your-prebuilt-invoice-application-main-method"></a>FÃ¼gen Sie der **Main**-Methode Ihrer vordefinierten Rechnungsanwendung den folgenden Code hinzu:

```csharp
// sample invoice document
string filePath = "(https://raw.githubusercontent.com/Azure-Samples/cognitive-services-REST-api-samples/master/curl/form-recognizer/sample-invoice.pdf";

using var stream = new FileStream(filePath, FileMode.Open);

AnalyzeDocumentOperation operation = await client.StartAnalyzeDocumentAsync("prebuilt-invoice", stream);

await operation.WaitForCompletionAsync();

AnalyzeResult result = operation.Value;

for (int i = 0; i < result.Documents.Count; i++)
{
    Console.WriteLine($"Document {i}:");

    AnalyzedDocument document = result.Documents[i];

    if (document.Fields.TryGetValue("VendorName", out DocumentField vendorNameField))
    {
        if (vendorNameField.ValueType == DocumentFieldType.String)
        {
            string vendorName = vendorNameField.AsString();
            Console.WriteLine($"Vendor Name: '{vendorName}', with confidence {vendorNameField.Confidence}");
        }
    }

    if (document.Fields.TryGetValue("CustomerName", out DocumentField customerNameField))
    {
        if (customerNameField.ValueType == DocumentFieldType.String)
        {
            string customerName = customerNameField.AsString();
            Console.WriteLine($"Customer Name: '{customerName}', with confidence {customerNameField.Confidence}");
        }
    }

    if (document.Fields.TryGetValue("Items", out DocumentField itemsField))
    {
        if (itemsField.ValueType == DocumentFieldType.List)
        {
            foreach (DocumentField itemField in itemsField.AsList())
            {
                Console.WriteLine("Item:");

                if (itemField.ValueType == DocumentFieldType.Dictionary)
                {
                    IReadOnlyDictionary<string, DocumentField> itemFields = itemField.AsDictionary();

                    if (itemFields.TryGetValue("Description", out DocumentField itemDescriptionField))
                    {
                        if (itemDescriptionField.ValueType == DocumentFieldType.String)
                        {
                            string itemDescription = itemDescriptionField.AsString();

                            Console.WriteLine($"  Description: '{itemDescription}', with confidence {itemDescriptionField.Confidence}");
                        }
                    }

                    if (itemFields.TryGetValue("Amount", out DocumentField itemAmountField))
                    {
                        if (itemAmountField.ValueType == DocumentFieldType.Double)
                        {
                            double itemAmount = itemAmountField.AsDouble();

                            Console.WriteLine($"  Amount: '{itemAmount}', with confidence {itemAmountField.Confidence}");
                        }
                    }
                }
            }
        }
    }

    if (document.Fields.TryGetValue("SubTotal", out DocumentField subTotalField))
    {
        if (subTotalField.ValueType == DocumentFieldType.Double)
        {
            double subTotal = subTotalField.AsDouble();
            Console.WriteLine($"Sub Total: '{subTotal}', with confidence {subTotalField.Confidence}");
        }
    }

    if (document.Fields.TryGetValue("TotalTax", out DocumentField totalTaxField))
    {
        if (totalTaxField.ValueType == DocumentFieldType.Double)
        {
            double totalTax = totalTaxField.AsDouble();
            Console.WriteLine($"Total Tax: '{totalTax}', with confidence {totalTaxField.Confidence}");
        }
    }

    if (document.Fields.TryGetValue("InvoiceTotal", out DocumentField invoiceTotalField))
    {
        if (invoiceTotalField.ValueType == DocumentFieldType.Double)
        {
            double invoiceTotal = invoiceTotalField.AsDouble();
            Console.WriteLine($"Invoice Total: '{invoiceTotal}', with confidence {invoiceTotalField.Confidence}");
        }
    }
}

```

## <a name="run-your-application"></a>AusfÃ¼hren der Anwendung

### <a name="net-command-line-interface-cli"></a>[.NET-Befehlszeilenschnittstelle (Command-Line Interface, CLI)](#tab/cli)

Ã–ffnen Sie die Eingabeaufforderung, navigieren Sie zu dem Verzeichnis, in dem Ihr Projekt enthalten ist, und geben Sie Folgendes ein:

```console
dotnet run formrecognizer-quickstart.dll
```

### <a name="visual-studio"></a>[Visual Studio](#tab/vs)

WÃ¤hlen Sie die grÃ¼ne SchaltflÃ¤che **Starten** neben â€žformRecognizer_quickstartâ€œ aus, um Ihr Programm zu kompilieren und auszufÃ¼hren, oder drÃ¼cken Sie **F5**.

  :::image type="content" source="../media/quickstarts/run-visual-studio.png" alt-text="Screenshot: AusfÃ¼hren Ihres Visual Studio-Programms":::

---

Herzlichen GlÃ¼ckwunsch! In dieser Schnellstartanleitung haben Sie das C#Â SDK fÃ¼r die Formularerkennung verwendet, um verschiedene Formulare und Dokumente auf unterschiedliche Arten zu analysieren. Lesen Sie als NÃ¤chstes die Referenzdokumentation, um die Formularerkennungs-API eingehender kennenzulernen.

## <a name="next-steps"></a>NÃ¤chste Schritte

> [!div class="nextstepaction"]
> [Referenzdokumentation zur REST-APIÂ v3.0](https://westus.dev.cognitive.microsoft.com/docs/services/form-recognizer-api-v3-0-preview-1/operations/AnalyzeDocument)